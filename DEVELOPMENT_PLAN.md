# PHP-EXT-LLHTTP 開発計画

## プロジェクト概要

llhttp の高性能 HTTP パーサーの PHP 拡張機能を開発し、シンプルで使いやすい独自の API を提供する。ネイティブ C 実装による優れたパフォーマンスと、PHP 開発者にとって直感的なインターフェースを両立する。

## 開発方針

### 設計原則

1. **シンプリシティ**: 複雑なイベントシステムを避け、直接的な API を提供
2. **高性能**: C ネイティブ実装によるゼロコピー処理
3. **使いやすさ**: PHP 開発者が慣れ親しんだパターンに準拠
4. **メモリ効率**: ストリーミング処理と適切なメモリ管理
5. **型安全**: PHP 8.0+ の厳密な型宣言

### 技術要件

- **PHP**: 8.0 以上
- **llhttp**: 最新安定版 (C ライブラリ)
- **Zend Engine**: 拡張機能開発 API
- **Build System**: autotools (phpize, configure, make)

## フェーズ別開発計画

### フェーズ 1: 基盤構築 (1-2週間)

#### 1.1 拡張機能骨格
- [ ] `config.m4` 作成 (autotools 設定)
- [ ] `php_llhttp.h` 作成 (拡張機能ヘッダ)
- [ ] `php_llhttp.c` 作成 (拡張機能エントリポイント)
- [ ] 基本的な拡張機能構造とモジュール初期化

#### 1.2 ビルドシステム
- [ ] llhttp ライブラリの検出と リンク設定
- [ ] PHP 拡張機能ビルドテスト
- [ ] CI/CD パイプライン基盤 (GitHub Actions)

#### 1.3 基本クラス定義
- [ ] `Llhttp\Parser` クラス骨格
- [ ] パーサータイプ定数 (REQUEST/RESPONSE)
- [ ] 基本的なオブジェクトライフサイクル

**成果物**: ビルド可能な最小限の拡張機能

### フェーズ 2: コア機能実装 (2-3週間)

#### 2.1 パーサー初期化
- [ ] `__construct(int $type)` 実装
- [ ] llhttp パーサー構造体の初期化
- [ ] パーサー設定とコールバック設定

#### 2.2 基本解析機能
- [ ] `parse(string $data): void` 実装
- [ ] `parseComplete(): void` 実装
- [ ] 基本的なエラーハンドリング

#### 2.3 状態管理
- [ ] `reset(): void` 実装
- [ ] 内部状態管理とクリーンアップ
- [ ] パーサーの再利用機能

#### 2.4 データアクセス API
- [ ] `getHttpMajor(): int` / `getHttpMinor(): int`
- [ ] `getMethod(): int` / `getMethodName(): string`
- [ ] `getStatusCode(): int`
- [ ] `shouldKeepAlive(): bool` / `messageNeedsEof(): bool`

**成果物**: 基本的な HTTP 解析機能

### フェーズ 3: データアクセス強化 (1-2週間)

#### 3.1 ヘッダー管理
- [ ] 自動ヘッダー収集機能の強化
- [ ] `getHeaders(): array` の最適化
- [ ] 複数値ヘッダーの適切な処理
- [ ] `getHeader(string $name): ?string` 実装

#### 3.2 ボディ処理
- [ ] `getBody(): string` 実装
- [ ] ストリーミングボディの効率的な処理
- [ ] 大きなボディデータの管理

#### 3.3 URL/URI 処理
- [ ] `getUrl(): string` 実装
- [ ] URL パース結果のキャッシュ
- [ ] クエリパラメータアクセス

**成果物**: 完全なデータアクセス API

### フェーズ 4: エラーハンドリング (1-2週間)

#### 4.1 エラーコード定義
- [ ] `Llhttp\ErrorCodes` クラス実装
- [ ] llhttp エラーコード定数
- [ ] エラーメッセージマッピング

#### 4.2 例外機能
- [ ] `Llhttp\Exception` クラス実装
- [ ] パーサーエラーの例外変換
- [ ] エラー位置とコンテキスト情報

#### 4.3 エラー回復
- [ ] パーサーエラー後の状態管理
- [ ] 部分的なデータ処理継続機能

**成果物**: 堅牢なエラーハンドリング

### フェーズ 5: 最適化とテスト (2-3週間)

#### 5.1 パフォーマンス最適化
- [ ] メモリアロケーション最適化
- [ ] ゼロコピー文字列処理
- [ ] ホットパス最適化

#### 5.2 メモリ管理
- [ ] リークテストと修正
- [ ] 循環参照の回避
- [ ] 適切なリソースクリーンアップ

#### 5.3 テストスイート
- [ ] 単体テスト (PHPUnit)
- [ ] 統合テスト
- [ ] パフォーマンステスト
- [ ] メモリリークテスト

#### 5.4 ドキュメント
- [ ] API ドキュメント
- [ ] 使用例とサンプルコード
- [ ] インストールガイド

**成果物**: 本番レディの拡張機能

### フェーズ 6: 配布とメンテナンス (継続)

#### 6.1 パッケージング
- [ ] PECL パッケージ作成
- [ ] ソースコード配布準備
- [ ] ライセンスとコピーライト整備

#### 6.2 CI/CD
- [ ] 自動テスト (複数 PHP バージョン)
- [ ] 自動ビルドとパッケージング
- [ ] リリース自動化

## 技術課題と解決策

### 1. メモリ管理

**課題**: C 構造体と PHP オブジェクトの適切なライフサイクル管理

**解決策**:
- PHP オブジェクトハンドラーでの適切なデストラクタ実装
- 参照カウンタと循環参照の適切な処理
- Valgrind を使用したメモリリーク検出

### 2. データ管理

**課題**: C から PHP へのデータ転送の効率化

**解決策**:
- `zend_string` の最適利用
- 適切なメモリ管理
- データのキャッシュ機能

### 3. 文字列処理

**課題**: C 文字列と PHP 文字列の効率的な変換

**解決策**:
- `zend_string` を使用したゼロコピー文字列処理
- バイナリセーフな文字列処理
- 大きなデータのストリーミング処理

### 4. スレッドセーフティ

**課題**: ZTS (Zend Thread Safety) 環境での安全性

**解決策**:
- TSRM マクロの適切な使用
- グローバル変数の回避
- スレッドローカルストレージの活用

## 品質保証

### テスト戦略

1. **単体テスト**: 各メソッドの動作確認
2. **統合テスト**: 実際の HTTP データでの動作確認
3. **パフォーマンステスト**: 既存の PHP HTTP パーサーとの性能比較
4. **メモリテスト**: リーク検出と安定性確認
5. **互換性テスト**: 各種 PHP バージョンでの動作確認

### 継続的品質管理

- **静的解析**: Clang Static Analyzer, Cppcheck
- **動的解析**: Valgrind, AddressSanitizer
- **コードレビュー**: プルリクエストベースの開発
- **自動テスト**: GitHub Actions での CI/CD

## リリース計画

### マイルストーン

- **v0.1.0**: フェーズ 1-2 完了 (基本機能)
- **v0.2.0**: フェーズ 3 完了 (データアクセス強化)
- **v0.3.0**: フェーズ 4 完了 (エラーハンドリング)
- **v1.0.0**: フェーズ 5 完了 (本番準備完了)

### 配布方法

1. **GitHub リリース**: ソースコード配布
2. **PECL**: 公式 PHP 拡張機能レポジトリ
3. **パッケージマネージャ**: 各 OS 用パッケージ

## リソース要件

### 開発環境

- **開発マシン**: Linux/macOS (C 開発環境)
- **テスト環境**: 複数 PHP バージョン (8.0-8.3)
- **CI/CD**: GitHub Actions

### 開発時間見積もり

- **総開発期間**: 約 10-14 週間
- **フルタイム換算**: 2-3 ヶ月
- **パートタイム**: 4-6 ヶ月

この計画に基づいて、段階的かつ確実に高品質な PHP 拡張機能を開発していきます。